/**
 * # terraform-fortios-advpn-sdwan-hub
 * 
 * Uses forked version of fortios provider
 * Requires FortiOS >= 7.0.1
 * Uses sub-table resources in BGP and SDWAN parent tables. Do not mix and match here.
 * 
 * Does stuff.
 * 
 * 
 */


terraform {
  required_providers {
    fortios = {
      source  = "poroping/fortios"
      version = ">= 2.3.4"
    }
  }
}

locals {
  advpn1 = [for i, v in var.interfaces : merge(var.interfaces[i], var.hub_links[i])]
  advpn  = { for advpn in local.advpn1 : "${advpn.remote_gw}_${advpn.advpn_id}" => advpn }
}

resource "fortios_vpnipsec_phase1interface" "phase1" {
  for_each = local.advpn

  vdomparam = var.vdom

  name                    = each.value.advpn_name
  type                    = "static"
  interface               = each.value.interface_name
  local_gw                = each.value.local_gw == "" ? null : each.value.local_gw
  ike_version             = 2
  peertype                = "any"
  network_overlay         = "enable"
  network_id              = each.value.advpn_id
  mode_cfg                = "enable"
  net_device              = "enable"
  proposal                = var.ipsec_proposal
  add_route               = "disable"
  dpd                     = "on-idle"
  auto_discovery_receiver = "enable"
  psksecret               = var.ipsec_psk
  dpd_retryinterval       = 5
  idle_timeout            = "enable"
  idle_timeoutinterval    = 5
  remote_gw               = each.value.remote_gw
}

resource "fortios_vpnipsec_phase2interface" "phase2" {
  for_each = local.advpn

  vdomparam = var.vdom

  name       = fortios_vpnipsec_phase1interface.phase1[each.key].name
  phase1name = fortios_vpnipsec_phase1interface.phase1[each.key].name
  proposal   = fortios_vpnipsec_phase1interface.phase1[each.key].proposal
  pfs        = "enable"
  dhgrp      = var.ipsec_dhgrp
}

resource "fortios_system_interface" "vpn_interface" {
  for_each = local.advpn

  autogenerated = "auto"

  description = "Managed by Terraform."
  name        = fortios_vpnipsec_phase1interface.phase1[each.key].name
  allowaccess = "ping"
  vdom        = var.vdom
}

resource "fortios_routerbgp_neighbor" "neighbor" {
  for_each = local.advpn

  vdomparam = var.vdom

  ip                          = each.value.tunnel_ip
  interface                   = fortios_vpnipsec_phase1interface.phase1[each.key].name
  remote_as                   = var.bgp_as
  connect_timer               = 1
  additional_path             = "receive"
  capability_graceful_restart = "enable"
  soft_reconfiguration        = "enable"
  route_map_in                = fortios_router_routemap.route_map[each.key].name
}

resource "fortios_routerbgp_network" "networks" {
  for_each = var.networks

  vdomparam = var.vdom

  prefix = each.key
}

resource "fortios_routerbgp_network" "overlay_networks" {
  for_each = var.overlay_networks

  vdomparam = var.vdom

  prefix = each.key
  # route_map = 
}

resource "fortios_routerbgp_network" "underlay_networks" {
  for_each = var.underlay_networks

  vdomparam = var.vdom

  prefix = each.key
  # route_map = 
}

locals {
  phase1names = setproduct(var.interregional_dynamic_vpn_networks, [for x in fortios_vpnipsec_phase1interface.phase1 : x.name])
}

resource "fortios_router_static" "interregional_dynamic_vpn_networks" {
  for_each = { for x in local.phase1names : "${x[0]}-${x[1]}" => x }

  vdomparam = var.vdom

  dst      = each.value[0]
  device   = each.value[1]
  priority = 5
}

# Will this cause issues on destroy if defined elsewhere?
resource "fortios_system_sdwan" "sdwan" {
  vdomparam = var.vdom

  status = "enable"
}

resource "fortios_system_sdwan_zone" "zone" {
  vdomparam = var.vdom

  name = "sdwan-hub${tostring(var.hub_id)}"
}

resource "fortios_system_sdwan_members" "spoke" {
  for_each = local.advpn

  vdomparam = var.vdom

  seq_num   = each.value.advpn_id
  interface = fortios_vpnipsec_phase1interface.phase1[each.key].name
  zone      = fortios_system_sdwan_zone.zone.name
  cost      = each.value.cost
  # gateway   = not needed?
}

resource "fortios_system_sdwan_health_check" "spoke" {
  # dynamic_sort_subtable = true
  vdomparam = var.vdom

  name                = "sla_hub${tostring(var.hub_id)}"
  server              = split("/", var.hub_loopback)[0]
  update_static_route = "disable"

  dynamic "members" {
    for_each = local.advpn

    content {
      seq_num = members.value.advpn_id
    }
  }

  sla {
    id                   = var.hub_id
    latency_threshold    = var.hub_sla.latency
    jitter_threshold     = var.hub_sla.jitter
    packetloss_threshold = var.hub_sla.packetloss
  }

  depends_on = [
    fortios_system_sdwan_members.spoke
  ]

}

resource "fortios_router_prefixlist" "pl_all" {
  for_each = local.advpn

  name = "pl-${each.value.advpn_name}-all"

  rule {
    id     = 1
    action = "permit"
    prefix = "0.0.0.0/0"
    le     = 32
  }
}

resource "fortios_router_routemap" "route_map" {
  for_each = local.advpn

  name = "tag-${each.value.advpn_name}"

  rule {
    id               = 10
    match_ip_address = fortios_router_prefixlist.pl_all[each.key].name
    set_route_tag    = each.value.advpn_id
  }
}

resource "fortios_system_sdwan_service" "spoke" {
  for_each = local.advpn

  vdomparam = var.vdom

  name                     = "dyn-hub${tostring(var.hub_id)}-${each.value.advpn_id}"
  hold_down_time           = 20
  mode                     = "sla"
  route_tag                = each.value.advpn_id
  sla_compare_method       = "order"
  minimum_sla_meet_members = 1

  priority_zone {
    name = fortios_system_sdwan_zone.zone.name // 7.0 only
  }

  sla {
    health_check = fortios_system_sdwan_health_check.spoke.name
    id           = var.hub_id
  }

}